---
title: '[운영체제] 2.4 운영 체제의 예'
categories:
  - Operating System
tags:
  - CS
  - Chapter2

comments: true 
---

> **'운영체제와 정보기술의 원리'**를 읽고 정리한 글입니다.

## 운영 체제의 가장 핵심적인 기능

- **자원을 효율적으로 관리하는 것.**

> 자원
> - 하드웨어 자원 : CPU, 메모리, 주변 장치 및 입출력 장치 등
> - 소프트웨어 자원 



## CPU를 관리하는 방법

- 일반적인 컴퓨터에는 CPU가 하나밖에 없지만 프로세스는 여러 개가 동시에 실행된다.
그러므로, 매 시점 **<u>어떠한 프로세스에게 CPU를 할당해 작업을 처리할 것인지</u>**를 결정하는 필요하다.

  ➜ **CPU 스케쥴링**



### CPU 스케쥴링
---


- 목표 : CPU를 가장 **<u>효율적으로 사용</u>**하면서도, 특정 프로세스가 **<u>불이익을 당하지 않도록</u>** 하는 것.

- 대표적인 CPU 스케쥴링 기법

  ✓ **선입선출 (FCFS : First Come First Served)**

  - 먼저 CPU를 사용하기 위해 도착한 프로세스를 **먼저 처리**해주는 방식

  - 먼저 CPU를 요청한 **<u>프로세스가 작업을 완료할 때까지</u>** 다른 프로세스들이 CPU를 이용하지 못함

  - 효율적인 사용 측면에서는 문제가 없지만, 전체 시스템 입장에서는 비효율적인 결과를 초래할 가능성이 있음
    > 예) 장시간 CPU를 사용해야하는 프로세스가 먼저 도착하고, 
    > 짧은 시간 동안 수행 가능한 프로세스들이 나중에 도착한 경우

    ----

  ✓ **라운드 로빈 (Round Robin)**

  - **<u>선입선출 기법의 단점을 보완</u>**하고자 고안된 기법

  - CPU를 한 번 **할당받아 사용할 수 있는 시간**을 일정한 **<u>고정된 시간</u>**으로 제한

    > 긴 작업을 요하는 프로세스가 CPU를 할당받더라도 정해진 시간이 지나면 CPU를 내어놓고 CPU의 서비스를 기다리는 줄의 제일 뒤에가서 기다려야한다.
    
    > 일반적으로 1회 할당 시간은 수 밀리 세컨드(ms) 정도의 단위를 사용한다.

    ----  

  ✓ **우선순위 (Priority)**

  - 수행 대기 중인 프로세스들에게 우선순위를 부여하고,  <br>
  **<u>우선순위가 높은 프로세스</u>**에게 CPU를 먼저 할당

    > '시스템 내의 프로세스 중에는 상대적으로 더 중요한 프로세스가 있을 수 있다.'
    > : 우선순위 스케쥴링의 철학 

  - 기다린 시간이 늘어날수록 우선순위를 점차 높여주는 방안도 <br>
  우선순위 스케쥴링에 활용 가능

    

## 메모리를 관리하는 방법

>  메모리
> - CPU가 직접 접근할 수 있는 컴퓨터 내부의 기억 장치
> - 프로그램이 CPU에서 수행되려면 해당 부분이 메모리에 올라가 있어야 한다.



- 메모리 관리를 위해 운영 체제는 메모리의 어느 부분이 어떤 프로그램에 의해 사용되고 있는지를 유지하게 된다.
이러한 정보는 **<u>주소(address)</u>**를 통해 관리된다.

  

- 운영 체제는 프로그램에게 메모리가 필요할 때 할당하고, <br>
더 이상 필요하지 않게 될 때 회수한다.
> 운영 체제는 이를 잘 판단해 전체 메모리 공간이 효율적으로 사용될 수 있도록 해야 한다.



- 운영 체제는 각 프로세스가 **<u>자신의 메모리 영역만을 접근</u>**할 수 있도록 관리해야한다.



### 물리적 메모리를 관리하는 방식
---

✓ **고정 분할 (fixed partition)** 방식

- 물리적 메모리를 몇 개의 **<u>영구적인 분할</u>**로 나누는 방식

- 나뉜 각각의 분할에는 **하나의 프로그램**이 적재

- 동시에 메모리에 적재되는 최대 프로그램의 수가 **<u>분할 개수</u>**로 한정

- **분할의 크기보다 큰 프로그램**은 적재가 불가능
  > 메모리의 효율적인 사용 측면에서 바람직하지 않다.

  > 분할이 고정적이기 때문에 분할의 크기보다 작은 프로그램이 적재되는 경우, 남는 영역이 발생하게 된다. 
  > ➜ 내부 조각 (internal fragmentation)
  > : 분할 영역에 올라온 프로그램에 의해서도 사용되지 않고 
  > 다른 프로세스에게도 할당될 수 없으므로 비효율적으로 낭비되는 공간

    ---

✓ **가변 분할 (variable partition)** 방식

- **<u>매 시점 프로그램의 크기에 맞게</u>** 메모리를 분할해서 사용하는 방식

  > 분할의 크기가 크기 때문에 큰 프로그램의 실행이 제한되는 문제는 발생하지 않는다.

- 물리적 메모리 크기보다 더 큰 프로그램의 실행은 여전히 불가능

- 분할의 크기, 개수가 **동적**으로 변하므로 기술적 관리 기법이 필요

- 내부 조각은 발생하지 않지만 **<u>외부 조각</u>**이 발생할 수 있음
  > 외부 조각 (external fragmentation)
  > : 프로그램에게 할당되지 않은 메모리 영역이지만 그 크기가 작아 프로그램을 올리지 못하는 메모리 영역

  > 예) 프로그램 A: 크기 100 ⇒ 메모리에 100만큼의 영역을 할당 받음 <br>
  > ​	(A 실행 중) <br>
  > ​	프로그램 B : 크기 50 ⇒ A의 영역 다음부터 메모리 50 할당 받음 <br>
  > ​	(A 작업 완료) <br>
  > ​	프로그램 C : 크기 80 ⇒ A의 영역에 할당 받음 // 20의 빈공간 발생 <br>
  > ​	프로그램 D : 크기 40  <br>
  > ​	// 크기가 20인 공간이 비어 있지만, 프로그램 D가 실행되기엔 충분하지 못한 공간 <br>
  > ​	➜ 외부 조각 

  
    ---

✓ **가상 메모리 (virtual memory)** 방식

- 최근의 거의 모든 컴퓨터 시스템에서 사용하는 메모리 관리 기법

- 물리적 메모리보다 더 큰 프로그램이 실행되는 것을 지원

- 실행될 수 있는 프로그램의 크기는 가상 메모리 크기에 의해 결정
  > 모든 프로그램은 물리적 메모리와는 독립적으로 주소가 0부터 시작하는 자신만의 가상 메모리를 갖게 된다.

  > 운영 체제는 가상 메모리의 주소를 물리적 메모리 주소로 매핑하는 기술을 이용해 
  > 주소를 변환시킨 후, 프로그램을 물리적 메모리에 올리게 된다.

- 현재 사용되고 있는 부분만 메모리에 올리고, 나머지는 하드 디스크와 같은 보조기억장치에 저장해주었다가 필요할 때 취하는 방식
  > 프로그램의 전체가 항상 동시에 실행되는 것은 아니기 때문이다.

- 프로그램을 구성하는 주소 공간은 **페이지**라는 동일한 크기의 작은 단위로 나뉘어 물리적 메모리와 스왑 영역에 일부분 저장 <br>
➜ 페이징 (paging) 기법
  > 스왑 영역 (swap area) 
  > : 이 때 사용되는 보조 기억 장치의 영역



## 주변 장치 및 입출력 장치를 관리하는 방법

- **<u>인터럽트</u>** (inter-rupt)라는 메커니즘을 통해 관리

  

### 인터럽트
---
- 주변 장치들이 **<u>CPU의 서비스가 필요한 경우</u>**에 발생시키는 신호
  > CPU는 평소에 CPU 스케쥴링에 따라 자신에게 주어진 작업을 수행하고 있다가
  > 인터럽트가 발생하면 잠시 멈추고 인터럽트에 의한 요청 서비스를 수행

- 운영 체제는 인터럽트를 처리한 후 원래 수행하던 작업으로 돌아오기 위해 
**<u>인터럽트 처리 직전에 수행중이던 작업의 상태를 저장</u>**해둔다.

  

- 운영 체제는 인터럽트 종류마다 서로 다른 인터럽트 처리 루틴을 가지고 있다.
  > 인터럽트 처리 루틴
  > - 인터럽트가 발생했을 때 해주어야 할 작업을 정의한 프로그램 코드
  > - 운영 체제 커널 내에 존재하는 코드
  > - CPU 스케쥴링, 메모리 관리 루틴 등 다양한 기능을 위한 커널 코드 중 일부분



### 컨트롤러
---
- 각 장치에서 **<u>어나는 업무에 대한 관리</u>**를 위한 일종의 작은 CPU

- 해당 장치에 대한 업무 처리하고 이를 **메인 CPU에 인터럽트를 발생**시켜 보고하는 역할
  > 예) 키보드에 사용자로부터 입력이 들어오면 키보드 컨트롤러가 인터럽트를 발생시켜 CPU에게 그 사실을 알려준다.
  >
  > 1. 키보드 컨트롤러가 인터럽트 발생
  > 2.  CPU는 작업 상태 저장 후, 키보드 인터럽트 처리 루틴을 찾음
  > 3. 키보드 인터럽트 처리 루틴은 인터럽트 처리 완료
  > 4. 인터럽트 발생하기 직전 상태 복구 후, 중단되었던 작업 재개





