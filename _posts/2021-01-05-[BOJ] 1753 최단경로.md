---
title: '[BOJ] 1753 ìµœë‹¨ê²½ë¡œ'
categories:
  - Algorithm
tags:
  - Java
  - Graph
  - BOJ

comments: true 
---
### ë‹¤ìµìŠ¤íŠ¸ë¼ ì˜ˆì œ

## ë¬¸ì œ
<a href = "https://www.acmicpc.net/problem/1753"> https://www.acmicpc.net/problem/1753 </a>
<br/>

## ë¬¸ì œ í’€ì´

``` java
package Baekjoon.Graph;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.PriorityQueue;
import java.util.Scanner;

//ìµœë‹¨ê²½ë¡œ - ê·¸ë˜í”„ (ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜)

/*
ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜ : ëª¨ë“  ì •ì ê¹Œì§€ì˜ ìµœë‹¨ ê²½ë¡œ êµ¬í•˜ê¸°
 */

class Node_graph implements Comparable<Node_graph> {
    int index; //ì •ì 
    int distance; //ê°€ì¤‘ì¹˜

    Node_graph (int index, int distance) {
        this.index = index;
        this.distance = distance;
    }

    @Override
    public int compareTo(Node_graph o) {
        return Integer.compare(distance, o.distance);
    }
}

public class BJ_1753 {

    static int V, E, K;
    static ArrayList<Node_graph>[] graph;
    static int[] dist;

    static final int INF = 987654321;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        V = sc.nextInt(); //ì •ì  ê°œìˆ˜
        E = sc.nextInt(); //ê°„ì„  ê°œìˆ˜
        K = sc.nextInt(); //ì‹œì‘ ì •ì  ë²ˆí˜¸

        graph = new ArrayList[V + 1];
        dist = new int[V + 1]; //ìµœë‹¨ ê²½ë¡œ ì €ì¥ ë°°ì—´(distance)

        Arrays.fill(dist, INF); //ë°°ì—´ ì´ˆê¸°í™” (ê°€ì¥ í° ê°’)

        for (int i = 1; i <= V; i++) {
            graph[i] = new ArrayList<>();
        }

        //ë¦¬ìŠ¤íŠ¸ì— ê·¸ë˜í”„ ì •ë³´ ì´ˆê¸°í™”
        for (int i = 0; i < E; i++) {
            int u = sc.nextInt(); //ì‹œì‘ ì •ì 
            int v = sc.nextInt(); //ë„ì°© ì •ì 
            int w = sc.nextInt(); //ê°€ì¤‘ì¹˜

            graph[u].add(new Node_graph(v, w));
        }

        dijkstra(K); //ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜

        String ans = "";
        for (int i = 1; i <= V; i++) {
            if (dist[i] == INF) { //ê²½ë¡œê°€ ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ê²½ìš°
                ans += "INF\n";
            } else {
                ans += dist[i] + "\n";
            }
        }

        System.out.println(ans);
    }

    public static void dijkstra(int start) {
        PriorityQueue<Node_graph> pq = new PriorityQueue<>(); //ìš°ì„ ìˆœìœ„í (ìµœì†Œê°’ë¶€í„° poll)
        boolean[] visited = new boolean[V + 1]; //ë°©ë¬¸ ì²´í¬ ë°°ì—´

        //ì‹œì‘ ì •ì ì€ ê±°ë¦¬ 0
        pq.add(new Node_graph(start, 0));
        dist[start] = 0;

        while (!pq.isEmpty()) {
            Node_graph node = pq.poll();
            int current = node.index; //í˜„ì¬ ì •ì 

            if (visited[current]) { //ë°©ë¬¸í•œ ì •ì ì´ë©´ ê±´ë„ˆë›°ê¸°
                continue;
            }

            visited[current] = true; //í˜„ì¬ ì •ì  ë°©ë¬¸ ì²´í¬

            for (Node_graph n : graph[current]) {

                //íŠ¹ì • ì •ì  = í˜„ì¬ ì •ì  ê±°ë¦¬ + íŠ¹ì • ì •ì  ê°€ì¤‘ì¹˜
                if (dist[n.index] > dist[current] + n.distance) { //ìµœë‹¨ê²½ë¡œì´ë©´ ì €ì¥ ë° ê°±ì‹ í•˜ê¸°
                    dist[n.index] = dist[current] + n.distance;
                    pq.add(new Node_graph(n.index, dist[n.index]));
                }
            }
        }
    }
}
```

## TMI

**21/06/16: ì•Œê³ ë¦¬ì¦˜ ìŠ¤í„°ë”” ë¬¸ì œ í’€ì´ğŸ¤“**
